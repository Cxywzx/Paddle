# 在Protobuf中支持多种类型的字典字段

## 背景

这项工作的背景是我们要使用代码生成器或者运行时自动生成模型配置函数，并在运行时自动检查配置的正确性。


现阶段如何编写一个Layer呢？可以参考[文章](http://www.paddlepaddle.org/doc/dev/new_layer/index.html)。主体可以分为以下几个步骤:

* 在[Protobuf文件](https://github.com/PaddlePaddle/Paddle/blob/develop/proto/ModelConfig.proto#L284)里，添加里面编写这个Layer需要的参数。如果这个Layer只需要size等常见配置，这个protobuf已经包含，复用即可。但是如果这个Layer有其他自定义的参数，就需要在这个文件里面添加字段。
	* 也就是目前新建Layer和修改Protobuf文件是强耦合的。且这个protobuf message已经有了52个字段了。
* 在C++端实现Layer
* 在Python端实现这个Layer的解析函数，Wrapper，V2Layer等等。


这个设计文档，旨在解决 Protobuf文件和Layer之间的耦合性，让用户新建一个Layer的时候不需要改Protobuf。并且，极大的简化Protobuf文件，清理原先protobuf中的冗余字段，例如合并LayerInputConfig中关于图像的若干字段(`ConvConfig`, `PoolConfig`, `NormConfig`等)。

## 实现方式

使用Protobuf中的[map](https://developers.google.com/protocol-buffers/docs/proto#maps)和[oneof](https://developers.google.com/protocol-buffers/docs/proto#oneof)将Paddle Potobuf中的配置简化成一个`map<string, variant>`形式。

简单的示例代码为:

```protobuf
message Attribute {
    oneof AttributeField {
   	     string s_value = 1;
   	     int    i_value = 2;
   	     float  f_value = 3;
   	     double d_value = 4;
   	     ...
    }
}

message LayerInputConfig {
  required string name = 1;
  map<string, Attribute> attributes = 2;
};

message LayerConfig {
   required string name = 1;
   required string type = 2;
   map<string, Attribute> attributes = 3;
   repeated LayerInputConfig inputs = 4;
}
```

其中，每种Layer都有不同的`type`。 而`attributes`作为一个`map`，他的Key可以被每个Layer自己定义。对于一些常见的配置参数，例如`activation`，可以共享一个key。对于一些layer专有属性，可以使用`.`分隔开。例如，对于CTCLayer可以设置`blank`属性，它的Key可以为`ctc.blank`。

这样，实现一个新的Layer，用户就不需要修改Protobuf消息了。并且，用户写一个新的Layer的时候，可以说明自己需要哪些属性，而这些属性的取值范围又是如何的。这样，我们在生成Python配置函数的代码时，可以生成运行时检查的代码。避免用户错误的配置神经网络。

## 样例配置

"""json
{
  "layers": [
    {
      "name": "image",
      "type": "data",
      "attributes": {
        "size": 65536
      }
    },
    {
      "name": "__conv_0__",
      "type": "exconv", 
      "attributes": {
        "size": 3297856,
        "activation": "linear",
        "num_filters": 64,
        "out.x": 227,
        "out.y": 227,
        "bias.name": "___conv_0__.wbias",
        "bias.shared": true
      },
      "inputs" : [{
        "name": "image",
        "attributes": {
          "parameter_name": "___conv_0__.w0",
          "conv.filter_size": 32,
          "conv.stride.x": 1,
          "conv.padding.x": 1,
          "conv.stride.y": 1,
          "conv.padding.y": 1,
          "conv.groups": 1,
          "conv.filter_channels": 1,

          "img.channels": 1,
          "img.x": 256,
          "img.y": 256
        }
      }]
    },
    {
      "name": "__batch_norm_0__",
      "type": "batch_norm",
      "attributes": {
        "size": 3297856,
        "activation": "relu",
        "out.x": 227,
        "out.y": 227,
        "bias.name": "___batch_norm_0__.wbias",
        "moving_average_fraction": 0.9
      },
      "inputs": [
        {
          "name": "__conv_0__",
          "attributes": {
            "parameter_name": "___batch_norm_0__.w0",
            "img.x": 227,
            "img.y": 227,
            "img.channels": 64
          }
        },
        {
          "name": "__conv_0__",
          "attributes": {
            "parameter_name": "___batch_norm_0__.w1"
          }
        },
        {
          "name": "__conv_0__",
          "attributes": {
            "parameter_name": "___batch_norm_0__.w2"
          }
        }
      ]
    },
  ]
}

"""

## 实现问题

实现这项工作目前来看有如下几个先决条件需要解决:

* 这项工作会修改 `Python <==> Paddle core`中间的protobuf消息定义，对于Python端Layer解析函数，需要有覆盖完整的单元测试，才能保证这一步工作进行完之后，系统行为没有问题。否则，直接修改 Protobuf 风险较高。
* `oneof`与`map`是`protobuf2`语法，但是这是在`Protobuf 3.0`之后的代码库中添加的功能，如果Paddle依赖这个功能，那么Paddle必须依赖Protobuf 3.0以上的Protobuf版本。
* 这个阶段保证Paddle的配置接口向后兼容，但是生成的Protobuf二进制有所修改。但保证可以新生成一个Protobuf二进制，使用命令 `
python -m paddle.utils.dump_config trainer_config.conf "" --binary > trainer_config.bin`

## 总结

* 最终目的: 用户只需要写Layer的C++实现，剩下的Python代码自动生成
* 阶段目的: 解耦合 Protobuf与Layer的C++实现
* 解决办法: 用`map`和`oneof`，将属性变成一个多种类型的字典
* 问题:
	* 需要先完善config_parser的单测，增加单测覆盖率
	* 这会让Paddle强制依赖`Protobuf 3.0+`的Protobuf
